use axum::{
    extract::Path,
    http::StatusCode,
    response::Json,
};
use serde_json::{json, Value};

use crate::models::{User, CreateUserRequest, SuccessResponse, ErrorResponse};

/// Get all users
#[utoipa::path(
    get,
    path = "/api/users",
    responses(
        (status = 200, description = "List of users retrieved successfully", body = [User]),
    ),
    tag = "users"
)]
pub async fn get_users() -> Json<Vec<User>> {
    // Mock data for demonstration
    let users = vec![
        User {
            id: 1,
            username: "john_doe".to_string(),
            email: "john@example.com".to_string(),
        },
        User {
            id: 2,
            username: "jane_smith".to_string(),
            email: "jane@example.com".to_string(),
        },
    ];
    
    Json(users)
}

/// Get user by ID
#[utoipa::path(
    get,
    path = "/api/users/{id}",
    responses(
        (status = 200, description = "User found", body = User),
        (status = 404, description = "User not found", body = ErrorResponse),
    ),
    params(
        ("id" = u32, Path, description = "User database id")
    ),
    tag = "users"
)]
pub async fn get_user_by_id(Path(id): Path<u32>) -> Result<Json<User>, (StatusCode, Json<ErrorResponse>)> {
    // Mock data - in real application, this would query a database
    if id == 1 {
        Ok(Json(User {
            id: 1,
            username: "john_doe".to_string(),
            email: "john@example.com".to_string(),
        }))
    } else {
        Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "User not found".to_string(),
            }),
        ))
    }
}

/// Create a new user
#[utoipa::path(
    post,
    path = "/api/users",
    request_body = CreateUserRequest,
    responses(
        (status = 201, description = "User created successfully", body = User),
        (status = 400, description = "Bad request", body = ErrorResponse),
    ),
    tag = "users"
)]
pub async fn create_user(Json(payload): Json<CreateUserRequest>) -> Result<(StatusCode, Json<User>), (StatusCode, Json<ErrorResponse>)> {
    // Mock user creation - in real application, this would save to database
    if payload.username.is_empty() || payload.email.is_empty() {
        return Err((
            StatusCode::BAD_REQUEST,
            Json(ErrorResponse {
                error: "Username and email are required".to_string(),
            }),
        ));
    }
    
    let new_user = User {
        id: 3, // Mock ID - would be generated by database
        username: payload.username,
        email: payload.email,
    };
    
    Ok((StatusCode::CREATED, Json(new_user)))
}

/// Delete user by ID
#[utoipa::path(
    delete,
    path = "/api/users/{id}",
    responses(
        (status = 200, description = "User deleted successfully", body = SuccessResponse),
        (status = 404, description = "User not found", body = ErrorResponse),
    ),
    params(
        ("id" = u32, Path, description = "User database id to delete")
    ),
    tag = "users"
)]
pub async fn delete_user(Path(id): Path<u32>) -> Result<Json<SuccessResponse>, (StatusCode, Json<ErrorResponse>)> {
    // Mock deletion - in real application, this would delete from database
    if id == 1 {
        Ok(Json(SuccessResponse {
            message: "User deleted successfully".to_string(),
        }))
    } else {
        Err((
            StatusCode::NOT_FOUND,
            Json(ErrorResponse {
                error: "User not found".to_string(),
            }),
        ))
    }
}

/// Health check endpoint
#[utoipa::path(
    get,
    path = "/health",
    responses(
        (status = 200, description = "Service is healthy", body = Value),
    ),
    tag = "health"
)]
pub async fn health_check() -> Json<Value> {
    Json(json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now().to_rfc3339()
    }))
}